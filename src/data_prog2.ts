export const prog2 = {
  semana1: [
    {
      texto:
        'Un módulo se dice abierto cuando, habiendo dado una descripción bien definida y estable, está disponible para ser utilizado por otros módulos.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
    },
    {
      texto: '¿Los procedimientos son funciones?',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
    },
    {
      texto:
        'Relaciona los 5 principios de construcción de software con sus respectivas definiciones.',
      descripciones: [
        'Propiedades que describen a un módulo capaz de ser extendido por el usuario o utilizado por otro módulo',
        'Los módulos deben corresponderse con las unidades sintácticas que ofrece el lenguaje utilizado',
        'No debe revelarse la forma en que los servicios ofrecidos por un módulo son implementados',
        'La documentación sobre un módulo debe estar contenida en su propio código',
        'Un único módulo debe conocer una lista exhaustiva de alternativas a utilizarse por el programa',
      ],
      opciones: [
        'Cambio Simple',
        'Acceso Uniforme',
        'Unidad Modular Lingüística',
        'Abierto-Cerrado',
        'Auto-documentación',
      ],
      correcta: [3, 2, 1, 4, 0],
      tipo: 'ordenar',
      multiple: true,
    },
    {
      texto:
        'Relaciona los enunciados con los Factores que determinan la Calidad de Software.',
      descripciones: [
        'Esfuerzo necesario para realizar modificaciones sobre una aplicación o sistema que ya se encuentra en funcionamiento',
        'Grado en que una aplicación o sistema puede ser transferido a otro hardware o sistema operativo',
        'Cantidad de recursos que necesita una aplicación o sistema para realizar las operaciones con tiempos de respuesta óptimos',
        'Esfuerzo requerido para que partes de una aplicación sean utilizadas en otras aplicaciones',
        'Grado en que una aplicación o sistema cumple con la definición y lo encomendado por el cliente',
        'Grado con que puede controlarse el acceso al software y/o a los datos de un sistema a personal no autorizado',
        'Grado en que una aplicación o sistema puede comunicarse con otras aplicaciones o sistemas',
        'Esfuerzo requerido para aprender el manejo de una aplicación, trabajar con ella, introducir datos y conseguir resultados',
      ],
      opciones: [
        'Eficiencia',
        'Integridad',
        'Portabilidad',
        'Facilidad de uso',
        'Corrección',
        'Interoperabilidad',
        'Flexibilidad',
        'Reusabilidad',
      ],
      correcta: [6, 2, 0, 7, 4, 1, 5, 3],
      tipo: 'ordenar',
      multiple: true,
    },
    {
      texto:
        'Elija, entre las siguientes combinaciones, la opción que crea correcta.\n' +
        'a. Reusabilidad & Robustez - Confiabilidad / Extensibilidad & Correctitud - Modularidad\n' +
        'b. Correctitud & Extensibilidad - Modularidad / Robustez & Reusabilidad - Confiabilidad\n' +
        'c. Correctitud & Robustez - Modularidad / Extensibilidad & Reusabilidad - Confiabilidad\n' +
        'd. Correctitud & Robustez - Confiabilidad / Extensibilidad & Reusabilidad - Modularidad',
      opciones: ['a', 'b', 'c', 'd'],
      correcta: 3,
    },
    {
      texto: '¿Las funciones son procedimientos?',
      opciones: ['Verdadero', 'Falso'],
      correcta: 0,
    },
    {
      texto: 'Seleccione las sentencias correctas sobre modularidad.',
      opciones: [
        'Descomposición Modular',
        'Composición Modular',
        'Entendimiento Modular',
        'Protección Modular',
        'Continuidad Modular',
      ],
      correcta: [0, 1, 2],
      multiple: true,
    },
    {
      texto:
        '¿Cuáles de las siguientes opciones constituyen parte de las reglas para asegurar la modularidad?',
      opciones: [
        'Interfaces directas',
        'Interfaces pequeñas',
        'Interfaces explícitas',
        'Ocultamiento de Información',
        'Protección modular',
        'Mapeo directo',
        'Cambio simple',
      ],
      correcta: [1, 2, 3, 5],
      multiple: true,
    },
    {
      texto:
        'Los términos procedimientos y funciones refieren a un conjunto de sentencias y declaraciones contenidas en una unidad con el fin de resolver un problema específico.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 0,
    },
    {
      texto:
        'Un tipo abstracto de datos es un tipo de datos que consta de datos y operaciones que pueden realizarse sobre estos datos, es definido por el programador y permite modelar una entidad real.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 0,
    },
    {
      texto:
        'Relaciona los Criterios con los Factores de Calidad que estos favorecen.',
      descripciones: [
        'Continuidad Modular',
        'Composición Modular',
        'Protección Modular',
        'Entendimiento Modular',
      ],
      opciones: ['Robustez', 'Mantenimiento', 'Extensibilidad', 'Reusabilidad'],
      correcta: [2, 3, 0, 1],
      tipo: 'ordenar',
      multiple: true,
    },
    {
      texto:
        'Elija el orden correcto de las etapas del Ciclo de Vida de un proyecto.',
      opciones: ['a', 'b', 'c', 'd', 'e'],
      correcta: 2,
    },
    {
      texto:
        '¿Cuáles son las subetapas de la Integración y Testeo del sistema?',
      opciones: [
        'Verificación / Mantenimiento',
        'Validación / Análisis',
        'Verificación / Validación',
        'Verificación / Análisis',
      ],
      correcta: 2,
    },
    {
      texto:
        'El mantenimiento adaptativo hace referencia a la adaptación de la aplicación a nuevas circunstancias, requerimientos o inclusión de nuevas prestaciones.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 0,
    },
    {
      texto:
        'Los procedimientos y funciones deben obligatoriamente hacer uso de parámetros.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
    },
    {
      texto: 'Los tipos de datos NO son abstracciones.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
    },
    {
      texto:
        'Todos los lenguajes de programación soportan los mismos tipos de datos.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
    },
    {
      texto:
        'Relaciona las distintas perspectivas con su respectiva descripción.',
      descripciones: [
        'Visión con base en la manufactura',
        'Visión del usuario',
        'Visión con base en el juicio',
        'Visión basada en el valor',
        'Visión del producto',
      ],
      opciones: [
        'Adecuación al propósito',
        'Conformidad con la especificación',
        'Depende de la cantidad de dinero que el usuario está dispuesto a pagar',
        'Algo que se puede reconocer, pero no definir',
        'Vinculada a las características inherentes del producto',
      ],
      correcta: [1, 0, 3, 2, 4],
      tipo: 'ordenar',
      multiple: true,
    },
    {
      texto:
        'En el contexto de los Factores de calidad del software, los términos Corrección y Fiabilidad NO refieren a lo mismo.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 0,
    },
    {
      texto:
        'En casos excepcionales la Integración y Testeo del Sistema puede darse antes de la Codificación y Testeo de los Módulos.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
    },
  ],
  semana2: [
    {
      texto:
        'Elija el orden correcto de las etapas del Ciclo de Vida de un proyecto.',
      opciones: [
        '1. Análisis y especificaciones de requerimientos\n2. Diseño y especificación\n3. Integración y Testeo de Sistema\n4. Codificación y Testeo de módulos\n5. Liberación y Mantenimiento',
        '1. Estudio de Factibilidad\n2. Análisis y especificaciones de requerimientos\n3. Diseño y especificación\n4. Codificación y Testeo de módulos\n5. Integración y Testeo de Sistema',
        '1. Análisis y especificaciones de requerimientos\n2. Estudio de Factibilidad\n3. Codificación y Testeo de módulos\n4. Diseño y especificación\n5. Integración y Testeo de Sistema\n6. Liberación y Mantenimiento',
        '1. Estudio de Factibilidad\n2. Análisis y especificaciones de requerimientos\n3. Diseño y especificación\n4. Codificación y Testeo de módulos\n5. Integración y Testeo de Sistema\n6. Liberación y Mantenimiento',
        '1. Estudio de Factibilidad\n2. Diseño y especificación\n3. Análisis y especificaciones de requerimientos\n4. Codificación y Testeo de módulos\n5. Integración y Testeo de Sistema\n6. Liberación y Mantenimiento',
      ],
      correcta: 3,
    },
    {
      texto:
        '¿Cuáles son las subetapas de la Integración y Testeo del sistema?',
      opciones: [
        'Verificación\nAnálisis',
        'Validación\nAnálisis',
        'Verificación\nValidación',
        'Verificación\nMantenimiento',
      ],
      correcta: 2,
    },
    {
      texto:
        'Enlace los 5 principios de construcción de software con sus respectivas definiciones',
      descripciones: [
        'Propiedades que describen a un módulo capaz de ser extendido por el usuario o utilizado por otro módulo.',
        'Un único módulo debe conocer una lista exhaustiva de alternativas a utilizarse por el programa.',
        'No debe revelarse la forma en los servicios ofrecidos por un módulo son implementados.',
        'Los módulos deben corresponderse con las unidades sintácticas que ofrece el lenguaje utilizado.',
        'La documentación sobre un módulo debe estar contenida en su propio código.',
      ],
      opciones: [
        'Unidad Modular Lingüística',
        'Auto-documentación',
        'Cambio Simple',
        'Acceso Uniforme',
        'Abierto-Cerrado',
      ],
      correcta: [4, 2, 3, 0, 1],
      tipo: 'ordenar',
      multiple: true,
    },
    {
      texto:
        'Una los Criterios con los Factores de Calidad que estos favorecen',
      descripciones: [
        'Composición Modular',
        'Entendimiento Modular',
        'Protección Modular',
        'Continuidad Modular',
      ],
      opciones: ['Mantenimiento', 'Extensibilidad', 'Robustez', 'Reusabilidad'],
      correcta: [3, 0, 2, 1],
      tipo: 'ordenar',
      multiple: true,
    },
    {
      texto:
        'Elija, entre las siguientes combinaciones, la opción que crea correcta.',
      opciones: [
        'Correctitud & Extensibilidad - Modularidad\nRobustez & Reusabilidad - Confiabilidad',
        'Correctitud & Robustez - Confiabilidad\nExtensibilidad & Reusabilidad - Modularidad',
        'Reusabilidad & Robustez - Confiabilidad\nExtensibilidad & Correctitud - Modularidad',
        'Correctitud & Robustez - Modularidad\nExtensibilidad & Reusabilidad - Confiabilidad',
      ],
      correcta: 1,
    },
    {
      texto:
        'Un módulo se dice abierto cuando, habiendo dado una descripción bien definida y estable, está disponible para ser utilizado por otros módulos.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
    },
    {
      texto:
        'Los términos procedimientos y funciones refieren a un conjunto de sentencias y declaraciones contenidas en una unidad con el fin de resolver un problema específico, el cual puede ser invocado desde otro punto del programa.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 0,
    },
    {
      texto: '¿Las funciones son procedimientos?',
      opciones: ['Verdadero', 'Falso'],
      correcta: 0,
    },
    {
      texto: 'Seleccione las sentencias que cree son correctas',
      opciones: [
        'El criterio de Continuidad Modular especifica que los cambios que impactan un módulo se propaguen al resto.',
        'La Composición Modular trata de la creación de nuevos unidades de software creadas a partir de la combinación de otras ya existentes.',
        'En un programa donde se satisface el criterio de Protección Modular, los cambios que impactan un módulo NO se propagan al resto.',
        'La Descomposición Modular sigue la idea de poder descomponer un programa en módulos menos complejos.',
        'El Entendimiento Modular se relaciona a la facilidad para comprender el comportamiento de un módulo con solo leer su código.',
        'Se satisface el criterio de Composición Modular si se favorece la producción de elementos de software que pueden ser combinados para crear nuevos sistemas, posiblemente en un entorno diferente a aquel en el que se idearon.',
        'La Protección Modular especifica que las excepciones en tiempo de ejecución detectadas en un módulo, es decir, mientras el programa está corriendo, son contenidas y NO se propagan al resto de los módulos.',
        'La Descomposición Modular refiere a la descomposición de un problema en subproblemas menos complejos, conectados por una estructura simple, y que pueden resolverse en forma independiente.',
        'Un método favorece el Entendimiento Modular si facilita que quien lea un módulo pueda comprenderlo sin necesidad de acudir a otros módulos.',
      ],
      correcta: [1, 2, 5, 6, 7, 8],
      multiple: true,
    },
    {
      texto:
        'Los procedimientos y funciones deben obligatoriamente hacer uso de parámetros',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
    },
    {
      texto:
        'Todos los lenguajes de programación soportan los mismos tipos de datos',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
    },
    {
      texto: 'Python es un lenguaje dinámicamente tipado',
      opciones: ['Verdadero', 'Falso'],
      correcta: 0,
    },
    {
      texto: '¿Cuáles de las siguientes son palabras reservadas del lenguaje?',
      opciones: [
        'True',
        'print',
        'None',
        'elseif',
        'escape',
        'global',
        'stop',
        'do',
        'while',
        'break',
      ],
      correcta: [0, 2, 5, 8, 9],
      multiple: true,
    },
    {
      texto:
        'Una variable de tipo entero puede transformarse a una variable de tipo cadena de caracteres de la siguiente forma:\n\nVar1 = 9\nVar1 = str(var1)',
      opciones: ['Verdadero', 'Falso'],
      correcta: 0,
    },
    {
      texto:
        '¿Qué expresión, al evaluarse y encontrarse un elemento cuyo valor de verdad es falso (False) detiene la ejecución y retorna dicho valor?',
      opciones: ['or', 'and'],
      correcta: 1,
    },
    {
      texto:
        'Se llama paquete al conjunto de módulos que componen un programa.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 0,
    },
    {
      texto:
        "¿Qué imprime la siguiente instrucción?\n\nprint('Mi', 'nombre', 'es', 'Nicolas', sep='#')",
      opciones: [
        'Mi#nombre#es#Nicolas',
        'MinombreesNicolas',
        'Mi nombre es Nicolas',
      ],
      correcta: 0,
    },
    {
      texto:
        "¿Cuál es la salida del siguiente programa?\n\nnum = 968.19893842\nprint('%.2f' % num)",
      opciones: ['968.19', '968.19893842', '968'],
      correcta: 0,
    },
    {
      texto:
        'La salida del siguiente programa es: 15\n\nvariable = [1,2,3,4,5]\nfor i in range(len(variable)):\n    variable[i] += 1\nprint(variable)',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
    },
    {
      texto:
        'El siguiente programa encuentra todos los números entre 200 y 210 (incluidos) tal que cada dígito del número es par, y los imprime de forma ordenada separados por comas.',
      opciones: [
        '202, 204, 204, 206, 208',
        '200, 202, 204, 206, 208',
        '200, 202, 204, 206, 208, 210',
        '200, 202, 204, 208, 206',
        '190, 202, 204, 206, 208',
      ],
      correcta: 1,
    },
    {
      texto:
        'Elija la versión de código que sirva para encontrar todos los números divisibles por 7 pero que no son múltiplo de 5 entre 0 y 50 (incluidos).',
      opciones: [
        'numeros=[]\nfor numero in range(0, 51):\n    if (numero % 7 == 0) and (numero % 5 != 0):\n    numeros.append(str(numero))\nprint(",".join(numeros))',
        'numeros=[]\nfor numero in range(0, 51):\n    if (numero / 7 > 0) and (numero % 5 != 0):\n    numeros.append(str(numero))\nprint(",".join(numeros))',
        'numeros=[]\nfor numero in range(0, 51):\n    if (numero % 7 == 0) and (numero * 5 == 0):\n    numeros.append(str(numero))\nprint(",".join(numeros))',
      ],
      correcta: 0,
    },
  ],
  semana3: [
    {
      texto:
        "Dada la siguiente clase:\n\nclass NaveEspacial:\n    def __init__(self, co, comb):\n        self.color = co\n        self.combustible = comb\n        self.alertas = False\n\n    def obtenerCombustible(self):\n        return self.combustible\n\n    def establecerEstadoAlertas(self, estado):\n        self.alertas = estado\n\n    def agregarCombustible(self, cantidad):\n        if self.combustible + cantidad > 1000:\n            disponible = 1000 - self.combustible\n            print(f\"¡De los {cantidad} litros, solo se pudieron cargar {disponible} litros!\")\n            self.combustible = 1000\n        else:\n            self.combustible += cantidad\n            print(f\"¡Se cargaron {cantidad} litros!\")\n\nIndique cuál es la salida del siguiente programa:\n\nnave_espacial1 = NaveEspacial('R', 500)\nprint('Combustible de Nave 1: ' + str(nave_espacial1.obtenerCombustible()))\nnave_espacial1.establecerEstadoAlertas(True)\nnave_espacial1.agregarCombustible(700)\nprint('Combustible de Nave 1: ' + str(nave_espacial1.obtenerCombustible()))\n\nnave_espacial2 = NaveEspacial('A', 0)\nprint('Combustible de Nave 2: ' + str(nave_espacial2.obtenerCombustible()))\nnave_espacial2.establecerEstadoAlertas\nnave_espacial2.agregarCombustible(200)\nprint('Combustible de Nave 2: ' + str(nave_espacial2.obtenerCombustible()))",
      opciones: [
        'Combustible de Nave 1: 500\n¡De los 700 litros, solo se pudieron cargar 500 litros!\nCombustible de Nave 2: 0\n¡Se cargaron 200 litros!',
        'Combustible de Nave 1: 500\n¡De los 700 litros, solo se pudieron cargar 500 litros!\nCombustible de Nave 1: 1000\nCombustible de Nave 2: 0\nCombustible de Nave 2: 200',
        'Combustible de Nave 1: 500\nCombustible de Nave 1: 1000\nCombustible de Nave 2: 0\nCombustible de Nave 2: 200',
      ],
      correcta: 1,
    },
    {
      texto:
        "Dada la clase NaveEspacial:\n\n¿Qué sucede si se ejecuta el siguiente programa?\n\nnave_espacial1 = NaveEspacial()\nprint('Combustible de Nave 1: ' + str(nave_espacial1.obtenerCombustible()))\nnave_espacial1.establecerEstadoAlertas(True)\nnave_espacial1.agregarCombustible(700)\nprint('Combustible de Nave 1: ' + str(nave_espacial1.obtenerCombustible()))",
      opciones: [
        'La primer instrucción print falla porque el objeto no se inicializó correctamente',
        'Arroja un error, ya que el método __init__ espera que se proporcionen los parámetros',
        'Funciona normalmente',
      ],
      correcta: 1,
    },
    {
      texto:
        "Dada la clase NaveEspacial:\n\n¿Qué sucede si se ejecuta el siguiente programa?\n\nnave_espacial1 = NaveEspacial\nprint('Combustible de Nave 1: ' + str(nave_espacial1.obtenerCombustible()))\nnave_espacial1.establecerEstadoAlertas(True)\nnave_espacial1.agregarCombustible(700)\nprint('Combustible de Nave 1: ' + str(nave_espacial1.obtenerCombustible()))",
      opciones: [
        'Funciona normalmente',
        'La primer instrucción print falla porque el objeto nave_espacial1 no se inicializó correctamente',
        'Arroja un error porque __init__ espera parámetros',
      ],
      correcta: 1,
    },
    {
      texto:
        "Dada la clase NaveEspacial:\n\n¿Cuál es la salida del siguiente programa?\n\nnave_espacial1 = NaveEspacial('R', 500)\nnave_espacial1.establecerEstadoAlertas(True)\nnave_espacial1.combustible += 700\nprint(nave_espacial1.obtenerCombustible())",
      opciones: ['1200', '500', '700', '1000'],
      correcta: 0,
    },
    {
      texto:
        "Dada la clase NaveEspacial:\n\nEl siguiente programa imprime Nave 1 = Nave 2: True\n\nnave_espacial1 = NaveEspacial('R', 500)\nnave_espacial2 = NaveEspacial('R', 500)\nprint('Nave 1 = Nave 2: ' + str(nave_espacial1 == nave_espacial2))",
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
    },
    {
      texto:
        "Dada la siguiente clase:\n\nclass Pelota:\n    def __init__(self):\n        self.estado = 'FRENADA'\n\n    def obtenerEstado(self):\n        return self.estado\n\n    def rodar(self):\n        print('Rodando...')\n        self.estado = 'RODANDO'\n\n    def frenar(self):\n        print('Frenando...')\n        self.estado = 'FRENADA'\n\n    def imprimirEstado(self):\n        print('Estado: ' + self.estado)\n\nIndique cuál será la salida del siguiente código:\n\npelota = Pelota()\npelota.imprimirEstado()\npelota.rodar()\nprint(pelota.obtenerEstado())\npelota.frenar()\npelota.imprimirEstado()",
      opciones: [
        'Estado: FRENADA\nRodando...\nRODANDO\nFrenando...\nEstado: FRENADA',
        'FRENADA\nrodando...\nRODANDO\nfrenando...\nFRENADA',
        "Estado: FRENADA\nRodando...\n'RODANDO'\nFrenando...\nEstado: FRENADA",
        'Error de sintaxis',
      ],
      correcta: 0,
    },
    {
      texto:
        'Dada la clase Pelota:\n\nIndique cuál será la salida del siguiente código:\n\npelota = new Pelota()\npelota.imprimir_estado()\npelota.rodar()\nprint(pelota.obtenerEstado())\npelota.frenar()\npelota.imprimir_estado()',
      opciones: [
        'Error de sintaxis',
        'Estado: FRENADA\nRodando...\nRODANDO\nFrenando...\nEstado: FRENADA',
        'FRENADA\nrodando...\nRODANDO\nfrenando...\nFRENADA',
      ],
      correcta: 0,
    },
    {
      texto:
        'Dada la clase Pelota:\n\n¿Qué tipo de servicios son rodar, frenar, obtenerEstado e imprimirEstado?',
      opciones: [
        'rodar y frenar son comandos, obtenerEstado e imprimirEstado son consultas',
        'todos son consultas',
        'ninguno es comando ni consulta',
        'todos son comandos',
      ],
      correcta: 0,
    },
    {
      texto:
        "Dada la siguiente clase:\n\nclass PelotaConNombre:\n    def __init__(self, nombre):\n        self.nombre = nombre\n        self.__establecerEstadoInicial()\n\n    def __establecerEstadoInicial(self):\n        self._establecerEstado('FRENADA')\n\n    def _establecerEstado(self, estado):\n        self.estado = estado\n\n    def establecerNombre(self, nombre):\n        self.nombre = nombre\n\n    def obtenerEstado(self):\n        return self.estado\n\n    def obtenerNombre(self):\n        return self.nombre\n\n    def rodar(self):\n        print('Rodando...')\n        self._establecerEstado('RODANDO')\n\n    def frenar(self):\n        print('Frenando...')\n        self._establecerEstado('FRENADA')\n\n    def imprimirEstado(self):\n        print('Estado de ' + self.nombre + ': ' + self.estado)\n\n¿Por qué el siguiente programa falla?\n\npelota1 = PelotaConNombre('Pelota 1')\npelota1.__establecerEstadoInicial()\npelota1.imprimirEstado()",
      opciones: [
        'El método __establecerEstadoInicial es privado',
        'El método __establecerEstadoInicial, al declararse con doble guion bajo, queda inaccesible convencionalmente',
        'El método __establecerEstadoInicial debe ser invocado por el constructor',
      ],
      correcta: 1,
    },
    {
      texto:
        "Dada la clase PelotaConNombre:\n\nEl programa:\n\npelota1 = PelotaConNombre('Pelota 1')\npelota2 = PelotaConNombre('Pelota 2')\npelota1.establecerNombre('Pelota 2')\npelota2.establecerNombre('Pelota 1')\nprint(pelota1.obtenerNombre())\nprint(pelota2.obtenerNombre())\n\nImprime: Pelota 1 / Pelota 2",
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
    },
    {
      texto:
        'El diagrama de clases es una especificación de una parte de la solución de un problema, que el programador elabora para que los diseñadores implementen y los responsables de testing verifiquen.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
    },
    {
      texto:
        '¿Por qué se considera incorrecto llamar al método __init__ constructor de una clase?',
      opciones: [
        'Porque al llamarse __init__ el objeto ya fue creado',
        'Porque __init__ es el constructor de un objeto y no de una clase',
        'Porque puede reescribirse',
        'Porque el concepto de constructor solo aplica a C++',
        'Las clases no utilizan constructores',
      ],
      correcta: 0,
    },
    {
      texto: 'Los términos Clase y Objeto pueden usarse indistintamente.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
    },
    {
      texto: 'Los nombres de las clases no pueden comenzar con un número.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 0,
    },
    {
      texto: 'Indique cuáles son los dos miembros válidos de una Clase',
      opciones: [
        'comportamiento',
        'enlaces',
        'atributos',
        'servicios',
        'nombres',
        'responsabilidades',
        'objetos',
        'variables',
      ],
      multiple: true,
      correcta: [2, 3],
    },
    {
      texto:
        'Los requisitos y la funcionalidad de los servicios pueden especificarse únicamente a través de diagramas.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
    },
    {
      texto: 'Una los términos con sus respectivas definiciones.',
      descripciones: [
        'Propiedad o cualidad relevante que caracteriza a todos los objetos de una clase.',
        'Servicio que modifica el valor de al menos un atributo.',
        'Servicio que no modifica el valor de ningún atributo.',
        'Mantienen valores compartidos por todos los objetos de una clase.',
        'Representa la abstracción del conjunto de objetos o instancias.',
        'Dependiendo del lenguaje, se usa para crear un objeto o inicializar la instancia de una clase.',
      ],
      opciones: [
        'Constructor',
        'Atributos de clase',
        'Consulta',
        'Nombre',
        'Comando',
        'Atributo',
      ],
      correcta: [5, 4, 2, 1, 3, 0],
      tipo: 'ordenar',
      multiple: true,
    },
    {
      texto:
        'En Python no existen los conceptos de privacidad que hay en otros lenguajes, donde se definen métodos y atributos como privados o protegidos.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 0,
    },
    {
      texto: 'La Firma o Signatura de un servicio está dada por:',
      opciones: [
        'Número de llamadas',
        'Número de comandos',
        'Nombre del servicio',
        'Tipo de los parámetros',
        'Longitud del nombre del servicio',
        'Tipo del resultado',
        'Número de parámetros',
        'Tipo de las variables definidas internamente',
      ],
      multiple: true,
      correcta: [2, 3, 6, 5],
    },
    {
      texto:
        'Señale cuáles de las siguientes se consideran convenciones válidas en el lenguaje Python',
      opciones: [
        'La primera letra del nombre de la clase se escribe en minúscula',
        'Las palabras de un identificador se escriben todas con inicial mayúscula',
        'La primera letra del nombre de atributos, comandos y consultas, se escribe con minúscula',
        'Los nombres de consultas que retornan el valor de un atributo comienzan con obtener, y comandos con establecer',
        'Se usan comentarios para identificar las secciones de atributos, comandos y consultas',
      ],
      multiple: true,
      correcta: [2, 3, 4],
    },
  ],
  semana3_2: [
    {
      texto:
        "Dada la siguiente clase:\n\nclass NaveEspacial:\n    def __init__(self, co, comb):\n        self.color = co\n        self.combustible = comb\n        self.alertas = False\n\n    def obtenerCombustible(self):\n        return self.combustible\n\n    def establecerEstadoAlertas(self, estado):\n        self.alertas = estado\n\n    def agregarCombustible(self, cantidad):\n        if self.combustible + cantidad > 1000:\n            disponible = 1000 - self.combustible\n            print(f\"¡De los {cantidad} litros, solo se pudieron cargar {disponible} litros!\")\n            self.combustible = 1000\n        else:\n            self.combustible += cantidad\n            print(f\"¡Se cargaron {cantidad} litros!\")\n\nIndique cuál es la salida del siguiente programa:\n\nnave_espacial1 = NaveEspacial('R', 500)\nprint('Combustible de Nave 1: ' + str(nave_espacial1.obtenerCombustible()))\nnave_espacial1.establecerEstadoAlertas(True)\nnave_espacial1.agregarCombustible(700)\nprint('Combustible de Nave 1: ' + str(nave_espacial1.obtenerCombustible()))\n\nnave_espacial2 = NaveEspacial('A', 0)\nprint('Combustible de Nave 2: ' + str(nave_espacial2.obtenerCombustible()))\nnave_espacial2.establecerEstadoAlertas\nnave_espacial2.agregarCombustible(200)\nprint('Combustible de Nave 2: ' + str(nave_espacial2.obtenerCombustible()))",
      opciones: [
        'Combustible de Nave 1: 500\n¡De los 700 litros, solo se pudieron cargar 500 litros!\nCombustible de Nave 2: 0\n¡Se cargaron 200 litros!',
        'Combustible de Nave 1: 500\n¡De los 700 litros, solo se pudieron cargar 500 litros!\nCombustible de Nave 1: 1000\nCombustible de Nave 2: 0\nCombustible de Nave 2: 200',
        'Combustible de Nave 1: 500\nCombustible de Nave 1: 1000\nCombustible de Nave 2: 0\nCombustible de Nave 2: 200',
      ],
      correcta: 1,
      respuestaCorrecta:
        'Combustible de Nave 1: 500\n¡De los 700 litros, solo se pudieron cargar 500 litros!\nCombustible de Nave 1: 1000\nCombustible de Nave 2: 0\nCombustible de Nave 2: 200',
    },
    {
      texto:
        "Dada la clase NaveEspacial:\n\n¿Qué sucede si se ejecuta el siguiente programa?\n\nnave_espacial1 = NaveEspacial()\nprint('Combustible de Nave 1: ' + str(nave_espacial1.obtenerCombustible()))\nnave_espacial1.establecerEstadoAlertas(True)\nnave_espacial1.agregarCombustible(700)\nprint('Combustible de Nave 1: ' + str(nave_espacial1.obtenerCombustible()))",
      opciones: [
        'La primer instrucción print falla porque el objeto no se inicializó correctamente',
        'Arroja un error, ya que el método __init__ espera que se proporcionen los parámetros',
        'Funciona normalmente',
      ],
      correcta: 1,
      respuestaCorrecta:
        'Arroja un error, ya que el método __init__ espera que se proporcionen los parámetros',
    },
    {
      texto:
        "Dada la clase NaveEspacial:\n\n¿Qué sucede si se ejecuta el siguiente programa?\n\nnave_espacial1 = NaveEspacial\nprint('Combustible de Nave 1: ' + str(nave_espacial1.obtenerCombustible()))\nnave_espacial1.establecerEstadoAlertas(True)\nnave_espacial1.agregarCombustible(700)\nprint('Combustible de Nave 1: ' + str(nave_espacial1.obtenerCombustible()))",
      opciones: [
        'Funciona normalmente',
        'La primer instrucción print falla porque el objeto nave_espacial1 no se inicializó correctamente',
        'Arroja un error porque __init__ espera parámetros',
      ],
      correcta: 1,
      respuestaCorrecta:
        'La primer instrucción print falla porque el objeto nave_espacial1 no se inicializó correctamente',
    },
    {
      texto:
        "Dada la clase NaveEspacial:\n\n¿Cuál es la salida del siguiente programa?\n\nnave_espacial1 = NaveEspacial('R', 500)\nnave_espacial1.establecerEstadoAlertas(True)\nnave_espacial1.combustible += 700\nprint(nave_espacial1.obtenerCombustible())",
      opciones: ['1200', '500', '700', '1000'],
      correcta: 0,
      respuestaCorrecta: '1200',
    },
    {
      texto:
        "Dada la clase NaveEspacial:\n\nEl siguiente programa imprime Nave 1 = Nave 2: True\n\nnave_espacial1 = NaveEspacial('R', 500)\nnave_espacial2 = NaveEspacial('R', 500)\nprint('Nave 1 = Nave 2: ' + str(nave_espacial1 == nave_espacial2))",
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
      respuestaCorrecta: 'Falso',
    },
    {
      texto:
        "Dada la siguiente clase:\n\nclass Pelota:\n    def __init__(self):\n        self.estado = 'FRENADA'\n\n    def obtenerEstado(self):\n        return self.estado\n\n    def rodar(self):\n        print('Rodando...')\n        self.estado = 'RODANDO'\n\n    def frenar(self):\n        print('Frenando...')\n        self.estado = 'FRENADA'\n\n    def imprimirEstado(self):\n        print('Estado: ' + self.estado)\n\nIndique cuál será la salida del siguiente código:\n\npelota = Pelota()\npelota.imprimirEstado()\npelota.rodar()\nprint(pelota.obtenerEstado())\npelota.frenar()\npelota.imprimirEstado()",
      opciones: [
        'Estado: FRENADA\nRodando...\nRODANDO\nFrenando...\nEstado: FRENADA',
        'FRENADA\nrodando...\nRODANDO\nfrenando...\nFRENADA',
        "Estado: FRENADA\nRodando...\n'RODANDO'\nFrenando...\nEstado: FRENADA",
        'Error de sintaxis',
      ],
      correcta: 0,
      respuestaCorrecta:
        'Estado: FRENADA\nRodando...\nRODANDO\nFrenando...\nEstado: FRENADA',
    },
    {
      texto:
        'Dada la clase Pelota:\n\nIndique cuál será la salida del siguiente código:\n\npelota = new Pelota()\npelota.imprimir_estado()\npelota.rodar()\nprint(pelota.obtenerEstado())\npelota.frenar()\npelota.imprimir_estado()',
      opciones: [
        'Error de sintaxis',
        'Estado: FRENADA\nRodando...\nRODANDO\nFrenando...\nEstado: FRENADA',
        'FRENADA\nrodando...\nRODANDO\nfrenando...\nFRENADA',
      ],
      correcta: 0,
      respuestaCorrecta: 'Error de sintaxis',
    },
    {
      texto:
        'Dada la clase Pelota:\n\n¿Qué tipo de servicios son rodar, frenar, obtenerEstado e imprimirEstado?',
      opciones: [
        'rodar y frenar son comandos, obtenerEstado e imprimirEstado son consultas',
        'todos son consultas',
        'ninguno es comando ni consulta',
        'todos son comandos',
      ],
      correcta: 0,
      respuestaCorrecta:
        'rodar y frenar son comandos, obtenerEstado e imprimirEstado son consultas',
    },
    {
      texto:
        "Dada la siguiente clase PelotaConNombre...\n\n¿Por qué el siguiente programa falla?\n\npelota1 = PelotaConNombre('Pelota 1')\npelota1.__establecerEstadoInicial()\npelota1.imprimirEstado()",
      opciones: [
        'El método __establecerEstadoInicial es privado',
        'El método __establecerEstadoInicial, al declararse con doble guion bajo, queda inaccesible convencionalmente',
        'El método __establecerEstadoInicial debe ser invocado por el constructor',
      ],
      correcta: 1,
      respuestaCorrecta:
        'El método __establecerEstadoInicial, al declararse con doble guion bajo, queda inaccesible convencionalmente',
    },
    {
      texto:
        'Dada la clase PelotaConNombre:\n\nEl programa imprime:\n\nPelota 1\nPelota 2',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
      respuestaCorrecta: 'Falso',
    },
    {
      texto:
        'El diagrama de clases es una especificación de una parte de la solución de un problema...',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
      respuestaCorrecta: 'Falso',
    },
    {
      texto:
        '¿Por qué se considera incorrecto llamar al método __init__ constructor de una clase?',
      opciones: [
        'Porque al llamarse __init__ el objeto ya fue creado',
        'Porque __init__ es el constructor de un objeto y no de una clase',
        'Porque puede reescribirse',
        'Porque el concepto de constructor solo aplica a C++',
        'Las clases no utilizan constructores',
      ],
      correcta: 0,
      respuestaCorrecta: 'Porque al llamarse __init__ el objeto ya fue creado',
    },
    {
      texto: 'Los términos Clase y Objeto pueden usarse indistintamente.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
      respuestaCorrecta: 'Falso',
    },
    {
      texto: 'Los nombres de las clases no pueden comenzar con un número.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 0,
      respuestaCorrecta: 'Verdadero',
    },
    {
      texto: 'Indique cuáles son los dos miembros válidos de una Clase',
      opciones: [
        'comportamiento',
        'enlaces',
        'atributos',
        'servicios',
        'nombres',
        'responsabilidades',
        'objetos',
        'variables',
      ],
      multiple: true,
      correcta: [2, 3],
      respuestaCorrecta: 'atributos, servicios',
    },
    {
      texto:
        'Los requisitos y la funcionalidad de los servicios pueden especificarse únicamente a través de diagramas.',
      opciones: ['Verdadero', 'Falso'],
      correcta: 1,
      respuestaCorrecta: 'Falso',
    },
    {
      texto: 'Una los términos con sus respectivas definiciones.',
      descripciones: [
        'Propiedad o cualidad relevante que caracteriza a todos los objetos de una clase.',
        'Servicio que modifica el valor de al menos un atributo.',
        'Servicio que no modifica el valor de ningún atributo.',
        'Mantienen valores compartidos por todos los objetos de una clase.',
        'Representa la abstracción del conjunto de objetos o instancias.',
        'Dependiendo del lenguaje, se usa para crear un objeto o inicializar la instancia de una clase.',
      ],
      opciones: [
        'Constructor',
        'Atributos de clase',
        'Consulta',
        'Nombre',
        'Comando',
        'Atributo',
      ],
      correcta: [5, 4, 2, 1, 3, 0],
      tipo: 'ordenar',
      multiple: true,
      respuestaCorrecta:
        'Atributo, Comando, Consulta, Atributos de clase, Nombre, Constructor',
    },
    {
      texto:
        'En Python no existen los conceptos de privacidad que hay en otros lenguajes...',
      opciones: ['Verdadero', 'Falso'],
      correcta: 0,
      respuestaCorrecta: 'Verdadero',
    },
    {
      texto: 'La Firma o Signatura de un servicio está dada por:',
      opciones: [
        'Número de llamadas',
        'Número de comandos',
        'Nombre del servicio',
        'Tipo de los parámetros',
        'Longitud del nombre del servicio',
        'Tipo del resultado',
        'Número de parámetros',
        'Tipo de las variables definidas internamente',
      ],
      multiple: true,
      correcta: [2, 3, 6, 5],
      respuestaCorrecta:
        'Nombre del servicio, Tipo de los parámetros, Número de parámetros, Tipo del resultado',
    },
    {
      texto:
        'Señale cuáles de las siguientes se consideran convenciones válidas en Python',
      opciones: [
        'La primera letra del nombre de la clase se escribe en minúscula',
        'Las palabras de un identificador se escriben todas con inicial mayúscula',
        'La primera letra del nombre de atributos, comandos y consultas, se escribe con minúscula',
        'Los nombres de consultas que retornan el valor de un atributo comienzan con obtener, y comandos con establecer',
        'Se usan comentarios para identificar las secciones de atributos, comandos y consultas',
      ],
      multiple: true,
      correcta: [2, 3, 4],
      respuestaCorrecta:
        "La primera letra del nombre de atributos, comandos y consultas, se escribe con minúscula; Los nombres de consultas comienzan con 'obtener' y los comandos con 'establecer'; Se usan comentarios para identificar secciones",
    },
  ],
};
